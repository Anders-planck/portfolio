---
title: 'AWS Lambda Notifier Service'
summary: 'Serverless notification system built with AWS Lambda, SES, SQS, and SNS for scalable, reliable email delivery with comprehensive testing and local development support'
image: '/images/projects/notifier.svg'
author: 'Anders & A-Cube S.r.l.'
publishedAt: '2024-03-01'
tags: ['AWS Lambda', 'Python', 'Serverless', 'SES', 'SQS', 'SNS', 'SAM']
---

## Overview

**A3-Shared-Notifier** is a production-grade serverless notification service built with AWS Lambda and Python 3.12. It provides reliable, scalable email delivery through AWS SES with flexible triggering via SQS, SNS, and direct Lambda invocation, supporting both HTML and plain text content.

### Key Achievements

- ⚡ **Serverless Architecture**: AWS Lambda for infinite scalability
- 📧 **AWS SES Integration**: Reliable email delivery with bounce/complaint handling
- 🔄 **Multi-Trigger Support**: SQS, SNS, and direct Lambda invocation
- 🐳 **Local Development**: SAM Local for Docker-based testing
- 🧪 **Comprehensive Testing**: Unit and integration test suites
- 📊 **CloudWatch Logging**: Structured logging for monitoring
- 🔒 **IAM Security**: Principle of least privilege
- 🚀 **CI/CD Ready**: Automated deployment pipeline with SAM

---

## Technical Architecture

### System Design

```
┌──────────────────────────────────────────────────┐
│            Trigger Sources                        │
│   AWS SQS • AWS SNS • Direct Invocation          │
└────────────────┬─────────────────────────────────┘
                 │
┌────────────────▼─────────────────────────────────┐
│         AWS Lambda Function                       │
│    Python 3.12 • Email Processing • Validation   │
└──────┬──────────────────────────────┬────────────┘
       │                              │
┌──────▼──────────┐         ┌─────────▼────────────┐
│ AWS SES         │         │   CloudWatch         │
│ - Email Send    │         │   - Logs             │
│ - Bounce Track  │         │   - Metrics          │
│ - Complaint Mgmt│         │   - Alarms           │
└─────────────────┘         └──────────────────────┘
```

### Lambda Function Flow

```
SQS/SNS Event → Lambda Handler → Validate Payload
                                       ↓
                               Parse Email Content
                                       ↓
                           Generate HTML/Text Email
                                       ↓
                              Send via AWS SES
                                       ↓
                         Log to CloudWatch → Success
```

---

## Core Features

### 1. Lambda Handler

**Main Handler** (src/handler.py):
```python
import json
import boto3
import logging
from typing import Dict, Any, List
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

logger = logging.getLogger()
logger.setLevel(logging.INFO)

ses_client = boto3.client('ses')

def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    AWS Lambda handler for email notifications
    Supports SQS, SNS, and direct invocation
    """
    try:
        # Parse event based on source
        messages = parse_event(event)

        results = []
        for message in messages:
            result = process_message(message)
            results.append(result)

        return {
            'statusCode': 200,
            'body': json.dumps({
                'processed': len(results),
                'results': results
            })
        }

    except Exception as e:
        logger.error(f'Error processing event: {str(e)}', exc_info=True)
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def parse_event(event: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Parse event from different sources"""
    if 'Records' in event:
        # SQS or SNS event
        return [
            json.loads(record['body']) if 'body' in record
            else json.loads(record['Sns']['Message'])
            for record in event['Records']
        ]
    else:
        # Direct invocation
        return [event]

def process_message(message: Dict[str, Any]) -> Dict[str, Any]:
    """Process single email message"""
    # Validate required fields
    validate_message(message)

    # Build email
    email = build_email(
        sender=message['sender'],
        recipients=message['recipients'],
        subject=message['subject'],
        text_content=message.get('text_content', ''),
        html_content=message.get('html_content', ''),
        bucket_name=message.get('bucket_name')
    )

    # Send via SES
    response = ses_client.send_raw_email(
        Source=message['sender'],
        Destinations=message['recipients'],
        RawMessage={'Data': email.as_string()}
    )

    logger.info(f"Email sent successfully. MessageId: {response['MessageId']}")

    return {
        'success': True,
        'messageId': response['MessageId'],
        'recipients': message['recipients']
    }

def validate_message(message: Dict[str, Any]) -> None:
    """Validate message structure"""
    required_fields = ['sender', 'recipients', 'subject']

    for field in required_fields:
        if field not in message:
            raise ValueError(f'Missing required field: {field}')

    if not isinstance(message['recipients'], list):
        raise ValueError('Recipients must be a list')

    if not message['recipients']:
        raise ValueError('Recipients list cannot be empty')

    # Validate at least one content type present
    if not message.get('text_content') and not message.get('html_content'):
        raise ValueError('Either text_content or html_content must be provided')

def build_email(
    sender: str,
    recipients: List[str],
    subject: str,
    text_content: str = '',
    html_content: str = '',
    bucket_name: str = ''
) -> MIMEMultipart:
    """Build MIME multipart email"""
    msg = MIMEMultipart('alternative')
    msg['From'] = sender
    msg['To'] = ', '.join(recipients)
    msg['Subject'] = subject

    # Add text version
    if text_content:
        part1 = MIMEText(text_content, 'plain')
        msg.attach(part1)

    # Add HTML version
    if html_content:
        part2 = MIMEText(html_content, 'html')
        msg.attach(part2)

    # Add S3 attachment reference if provided
    if bucket_name:
        msg.add_header('X-S3-Bucket', bucket_name)

    return msg
```

### 2. SQS/SNS Integration

**SQS Message Format**:
```json
{
  "sender": "noreply@acubeapi.com",
  "recipients": ["user@example.com"],
  "subject": "Your Invoice is Ready",
  "text_content": "Your invoice #12345 is now available for download.",
  "html_content": "<h1>Invoice Ready</h1><p>Your invoice #12345 is now available.</p>",
  "bucket_name": "acube-invoices"
}
```

**SNS Topic Integration**:
```python
import boto3

sns_client = boto3.client('sns')

def publish_notification(topic_arn: str, email_data: Dict[str, Any]) -> None:
    """Publish email notification to SNS topic"""
    sns_client.publish(
        TopicArn=topic_arn,
        Message=json.dumps(email_data),
        Subject='Email Notification Request'
    )
```

**SQS Queue Processing**:
```python
def send_to_queue(queue_url: str, email_data: Dict[str, Any]) -> None:
    """Send email notification to SQS queue"""
    sqs_client = boto3.client('sqs')

    sqs_client.send_message(
        QueueUrl=queue_url,
        MessageBody=json.dumps(email_data)
    )
```

### 3. Local Development with SAM

**SAM Template** (template.yaml):
```yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Globals:
  Function:
    Timeout: 30
    Runtime: python3.12
    MemorySize: 256
    Environment:
      Variables:
        LOG_LEVEL: INFO

Resources:
  NotifierFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: handler.lambda_handler
      Description: Email notification service
      Policies:
        - SESCrudPolicy:
            IdentityName: "*"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt NotifierQueue.Arn
            BatchSize: 10
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref NotifierTopic

  NotifierQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: A3-Shared-Notifier
      VisibilityTimeout: 60
      MessageRetentionPeriod: 1209600  # 14 days

  NotifierTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: A3-Shared-Notifier
      DisplayName: A-Cube Notifier Topic

  NotifierLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${NotifierFunction}
      RetentionInDays: 30

Outputs:
  FunctionArn:
    Description: "Lambda Function ARN"
    Value: !GetAtt NotifierFunction.Arn
  QueueUrl:
    Description: "SQS Queue URL"
    Value: !Ref NotifierQueue
  TopicArn:
    Description: "SNS Topic ARN"
    Value: !Ref NotifierTopic
```

**Local Invocation**:
```bash
# Build Lambda function
sam build

# Local invocation with test event
sam local invoke NotifierFunction \
    --env-vars local/env.json \
    --event tests/events/sqs-email-event.json

# Start local API Gateway
sam local start-api

# Local debugging
sam local invoke NotifierFunction \
    --debug-port 5858 \
    --env-vars local/env.json \
    --event tests/events/sqs-email-event.json
```

### 4. Testing Strategy

**Unit Tests** (tests/unit/test_handler.py):
```python
import unittest
from unittest.mock import patch, MagicMock
from src.handler import lambda_handler, validate_message, build_email

class TestNotifierHandler(unittest.TestCase):

    def test_validate_message_success(self):
        """Test message validation with valid data"""
        message = {
            'sender': 'test@example.com',
            'recipients': ['user@example.com'],
            'subject': 'Test',
            'text_content': 'Hello'
        }
        # Should not raise exception
        validate_message(message)

    def test_validate_message_missing_sender(self):
        """Test validation fails with missing sender"""
        message = {
            'recipients': ['user@example.com'],
            'subject': 'Test'
        }
        with self.assertRaises(ValueError) as context:
            validate_message(message)
        self.assertIn('sender', str(context.exception))

    def test_validate_message_empty_recipients(self):
        """Test validation fails with empty recipients"""
        message = {
            'sender': 'test@example.com',
            'recipients': [],
            'subject': 'Test'
        }
        with self.assertRaises(ValueError) as context:
            validate_message(message)
        self.assertIn('empty', str(context.exception))

    @patch('src.handler.ses_client')
    def test_lambda_handler_success(self, mock_ses):
        """Test successful Lambda handler execution"""
        mock_ses.send_raw_email.return_value = {
            'MessageId': 'test-message-id-123'
        }

        event = {
            'sender': 'test@example.com',
            'recipients': ['user@example.com'],
            'subject': 'Test Email',
            'text_content': 'Test content'
        }

        response = lambda_handler(event, None)

        self.assertEqual(response['statusCode'], 200)
        mock_ses.send_raw_email.assert_called_once()

    def test_build_email_with_html(self):
        """Test email building with HTML content"""
        email = build_email(
            sender='test@example.com',
            recipients=['user@example.com'],
            subject='Test',
            text_content='Plain text',
            html_content='<h1>HTML</h1>'
        )

        self.assertEqual(email['Subject'], 'Test')
        self.assertEqual(email['From'], 'test@example.com')
        self.assertIn('text/plain', email.as_string())
        self.assertIn('text/html', email.as_string())
```

**Integration Tests** (tests/integration/test_ses.py):
```python
import boto3
import pytest
from src.handler import lambda_handler

@pytest.fixture
def ses_client():
    return boto3.client('ses', region_name='eu-west-1')

def test_send_email_integration(ses_client):
    """Integration test with actual SES (requires verified emails)"""
    event = {
        'sender': 'verified-sender@acubeapi.com',
        'recipients': ['verified-recipient@acubeapi.com'],
        'subject': 'Integration Test',
        'text_content': 'This is an integration test',
        'html_content': '<p>This is an integration test</p>'
    }

    response = lambda_handler(event, None)

    assert response['statusCode'] == 200
    body = json.loads(response['body'])
    assert body['processed'] == 1
    assert body['results'][0]['success'] is True
```

---

## Development Workflow

### Docker Development Environment

**Makefile**:
```makefile
.PHONY: init build up down test

init:
    @make build
    @make up

build:
    docker-compose build

up:
    docker-compose up -d

down:
    docker-compose down

test:
    @make tests.unit
    @make tests.integration

tests.unit:
    docker-compose exec python pytest tests/unit -v

tests.integration:
    docker-compose exec python pytest tests/integration -v

lint:
    cfn-lint template.yaml
    yamllint template.yaml

invoke.local:
    sam local invoke NotifierFunction \
        --env-vars local/env.json \
        --event tests/events/sqs-email-event.json \
        --docker-network acube-notifier_default
```

---

## Deployment

### SAM Deployment

**Deploy to Dev**:
```bash
# Build Lambda function
sam build -u

# Deploy to dev environment
sam deploy \
    --profile acube-dev \
    --config-env dev \
    --no-confirm-changeset
```

**Deploy to Production**:
```bash
# Build with production optimizations
sam build -u --use-container

# Deploy to production
sam deploy \
    --profile acube-prod \
    --config-env production \
    --no-confirm-changeset \
    --parameter-overrides \
        Environment=production \
        LogRetentionDays=90
```

**SAM Config** (samconfig.toml):
```toml
version = 0.1

[default.deploy.parameters]
stack_name = "A3-Shared-Notifier"
region = "eu-west-1"
capabilities = "CAPABILITY_IAM"
parameter_overrides = "Environment=dev"

[dev.deploy.parameters]
stack_name = "A3-Shared-Notifier-Dev"
parameter_overrides = "Environment=dev LogRetentionDays=7"

[production.deploy.parameters]
stack_name = "A3-Shared-Notifier-Prod"
parameter_overrides = "Environment=production LogRetentionDays=90"
```

---

## Monitoring & Logging

### CloudWatch Logs

**Structured Logging**:
```python
import logging
import json

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def log_event(event_type: str, data: Dict[str, Any]) -> None:
    """Log structured event to CloudWatch"""
    log_entry = {
        'timestamp': datetime.utcnow().isoformat(),
        'event_type': event_type,
        'data': data
    }
    logger.info(json.dumps(log_entry))

# Usage
log_event('email_sent', {
    'message_id': response['MessageId'],
    'recipients': recipients,
    'subject': subject
})
```

### CloudWatch Alarms

```yaml
Resources:
  ErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: NotifierErrors
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref NotifierFunction
```

---

## Technical Stack Summary

### Runtime & Framework
- Python 3.12 - Modern Python
- AWS Lambda - Serverless compute
- AWS SAM - Deployment framework

### AWS Services
- AWS SES - Email delivery
- AWS SQS - Message queue
- AWS SNS - Pub/sub messaging
- CloudWatch - Logging & monitoring

### Development Tools
- Docker - Local development
- Pytest - Testing framework
- Boto3 - AWS SDK for Python
- cfn-lint - CloudFormation validation

---

## Best Practices Implemented

1. **Idempotency**: Message deduplication via SQS
2. **Error Handling**: Comprehensive exception handling
3. **Retry Logic**: SQS visibility timeout and DLQ
4. **Monitoring**: Structured logging and CloudWatch alarms
5. **Security**: IAM least privilege, encrypted SQS
6. **Testing**: Unit and integration test coverage
7. **Documentation**: Inline comments and README
8. **CI/CD**: Automated deployment with SAM

---

## Conclusion

**A3-Shared-Notifier** demonstrates production-ready serverless architecture with AWS Lambda, providing reliable, scalable email notifications with comprehensive testing and monitoring capabilities.

**License**: Proprietary (A-Cube S.r.l.)
